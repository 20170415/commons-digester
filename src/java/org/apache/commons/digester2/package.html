<!-- $Id$
  
 Copyright 2001-2005 The Apache Software Foundation.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
  
       http://www.apache.org/licenses/LICENSE-2.0
  
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
--> 
<html>
<head>
<title>Package Documentation for org.apache.commons.digester Package</title>
</head>
<body bgcolor="white">

<p>The Digester package provides for rules-based processing of arbitrary
XML documents.</p>

<a name="doc.Description"></a>
<div align="center">
<a href="#doc.Depend">[Dependencies]</a>
<a href="#doc.Intro">[Introduction]</a>
<a href="#doc.Properties">[Configuration Properties]</a>
<a href="#doc.Stack">[The Object Stack]</a>
<a href="#doc.Patterns">[Element Matching Patterns]</a>
<a href="#doc.Actions">[Processing Actions]</a>
<a href="#doc.ActionFactory">[The Action Factory]</a>
<a href="#doc.Logging">[Logging]</a>
<a href="#doc.Usage">[Usage Example]</a>
<a href="#doc.Namespace">[Namespace Aware Parsing]</a>
<a href="#doc.Pluggable">[Pluggable Rules Processing]</a>
<a href="#doc.RegisteringDTDs">[Registering DTDs]</a>
<a href="#doc.troubleshooting">[Troubleshooting]</a>
<a href="#doc.FAQ">[FAQ]</a>
<a href="#doc.extensions">[Extensions]</a>
<a href="#doc.Limits">[Known Limitations]</a>
</div>

<a name="doc.Depend"></a>
<h3>External Dependencies</h3>

<p>The <em>Digester</em> component is dependent upon implementations of the
following standard libraries:</p>

<ul>
<li><strong>XML Parser</strong> compatible with the JAXP/1.1 specification.
    Examples compatible implementations include:
    <ul>
    <li><a href="http://java.sun.com/xml">JAXP/1.1 Reference Implementation</a></li>
    <li><a href="http://xml.apache.org/xerces-j">Xerces</a> (Version 1.3.1 or later)</li>
    </ul></li>
</ul>

<p>It is also dependent on the following 
<a href='http://jakarta.apache.org/commons'>Jakarta Commons</a>
library components:</p>

<ul>
<li>Commons-Logging 1.0.x</li>
<li>Commons-BeanUtils 1.7</li>
</ul>

<a name="doc.Intro"></a>
<h3>Introduction</h3>

<p>In many application environments that deal with XML-formatted data, it is
useful to be able to process an XML document in an "event driven" manner,
where particular Java objects are created (or methods of existing objects
are invoked) when particular patterns of nested XML elements have been
recognized.  Developers familiar with the Simple API for XML Parsing (SAX)
approach to processing XML documents will recognize that the Digester provides
a higher level, more developer-friendly interface to SAX events, because most
of the details of navigating the XML element hierarchy are hidden -- allowing
the developer to focus on the processing to be performed.</p>

<p>In order to use a Digester, the following basic steps are required:</p>

<ul>
<li>Create a new instance of the
    <code>org.apache.commons.digester.Digester</code> class.  Previously
    created Digester instances may be safely reused, as long as you have
    completed any previously requested parse, and you do not try to utilize
    a particular Digester instance from more than one thread at a time.</li>
<li>Set any desired <a href="#doc.Properties">configuration properties</a>
    that will customize the operation of the Digester when you next initiate
    a parse operation.</li>
<li>Optionally, push any desired initial object(s) onto the Digester's
    <a href="#doc.Stack">object stack</a>.</li>
<li>Register all of the <a href="#doc.Patterns">element matching patterns</a>
    for which you wish to have <a href="#doc.Actions">processing actions</a>
    fired when this pattern is recognized in an input document.  You may
    register as many actions as you like for any particular pattern.  If there
    is more than one action for a given pattern, the actions will be executed in
    the order that they were added.</li>
<li>Call the <code>digester.parse()</code> method, passing a reference to the
    XML document to be parsed in one of a variety of forms.  See the
    <a href="Digester.html#parse(java.io.File)">Digester.parse()</a>
    documentation for details.  Note that you will need to be prepared to
    catch any <code>IOException</code> or <code>SAXException</code> that is
    thrown by the parser, or any runtime expression that is thrown by one of
    the processing actions.</li>
</ul>

<p>For example code, see <a href="#doc.Usage"> the usage 
examples</a>, and <a href="#doc.FAQ.Examples"> the FAQ </a>.</p>

<a name="doc.Properties"></a>
<h3>Digester Configuration Properties</h3>

<p>A <code>org.apache.commons.digester.Digester</code> instance contains several
configuration properties that can be used to customize its operation.  These
properties <strong>must</strong> be configured before you call one of the
<code>parse()</code> variants, in order for them to take effect on that
parse.</p>

<blockquote>
  <table border="1">
    <tr>
      <th width="15%">Property</th>
      <th width="85%">Description</th>
    </tr>
    <tr>
      <td align="center">classLoader</td>
      <td>You can optionally specify the class loader that will be used to
          load classes when required by the <code>CreateObjectAction</code>
          and <code>CreateObjectWithFactoryAction</code> actions.  If not
          specified, application classes will be loaded from the thread's
          context class loader (unless the <code>useContextClassLoader</code>
          property is set to <code>false</code>) or the same class loader that
          was used to load the <code>Digester</code> class itself.</td>
    </tr>
    <tr>
      <td align="center">errorHandler</td>
      <td>You can optionally specify a SAX <code>ErrorHandler</code> that
          is notified when parsing errors occur.  By default, any parsing
          errors that are encountered cause an exception to be thrown, thus
          terminating any processing.</td>
    </tr>
    <tr>
      <td align="center">ruleManager</td>
      <td>The <code>RuleManager</code> component that actually performs matching
          of registered patterns against the current xml element path is
          pluggable.  By default, Digester uses the 
          <code>DefaultRuleManager</code> implementation that behaves as 
          described in this document.  See
          <a href="#doc.Pluggable">Pluggable Pattern Matching</a> for
          more information.</td>
    </tr>
    <tr>
      <td align="center">useContextClassLoader</code></td>
      <td>A boolean that is set to <code>false</code> if you explicitly want
          to ignore any context-classloader associated with the current thread
          when application <code>CreateObjectWithFactoryAction</code> or
          <code>CreateObjectAction</code> need to load classes. By default,
          classes will be loaded from the classloader explicitly set by the
          caller (if one exists), then the context-classloader (if one exists),
          and from the class loader that loaded this <code>Digester</code> class
          otherwise.
    </tr>
    <tr>
      <td align="center">validating</td>
      <td>A boolean that is set to <code>true</code> if you wish to validate
          the XML document against a Document Type Definition (DTD) that is
          specified in its <code>DOCTYPE</code> declaration.  The default
          value of <code>false</code> requests a parse that only detects
          "well formed" XML documents, rather than "valid" ones.</td>
    </tr>
  </table>
</blockquote>

<p>In addition to the scalar properties defined above, you can also register
a local copy of a Document Type Definition (DTD) that is referenced in a
<code>DOCTYPE</code> declaration.  Such a registration tells the XML parser
that, whenever it encounters a <code>DOCTYPE</code> declaration with the
specified public identifier, it should utilize the actual DTD content at the
registered system identifier (a URL), rather than the one in the
<code>DOCTYPE</code> declaration.</p>

<p>For example, the Struts framework controller servlet could use the following
registration in order to tell Struts to use a local copy of the DTD for the
Struts configuration file. This would allow usage of Struts in environments that
are not connected to the Internet, and speed up processing even at Internet
connected sites (because it avoids the need to go across the network).</p>

<pre>
    digester.registerKnownEntity(
        "-//Apache Software Foundation//DTD Struts Configuration 1.0//EN",
        "/org/apache/struts/resources/struts-config_1_0.dtd");
</pre>

<p>As a side note, the system identifier used in this example is the path
that would be passed to <code>java.lang.ClassLoader.getResource()</code>
or <code>java.lang.ClassLoader.getResourceAsStream()</code>.  The actual DTD
resource is loaded through the same class loader that loads all of the Struts
classes -- typically from the <code>struts.jar</code> file.</p>

<a name="doc.Stack"></a>
<h3>The Object Stack</h3>

<p>One very common use of <code>org.apache.commons.digester.Digester</code>
technology is to dynamically construct a tree of Java objects, whose internal
organization, as well as the details of property settings on these objects,
are configured based on the contents of the XML document.  In fact, the
primary reason that the Digester package was created (it was originally part
of Struts, and then moved to the Commons project because it was recognized
as being generally useful) was to facilitate the
way that the Struts controller servlet configures itself based on the contents
of your application's <code>struts-config.xml</code> file.</p>

<p>To facilitate this usage, the Digester exposes a stack that can be
manipulated by processing actions that are fired when the associated patterns
match the current xml element.  The usual stack-related operations are made
available, including the following:</p>

<ul>
<li><a href="Digester.html#peek()">peek()</a> - Return a reference to the top
    object on the stack, without removing it.</li>
<li><a href="Digester.html#pop()">pop()</a> - Remove the top object from the
    stack and return it.</li>
<li><a href="Digester.html#push(java.lang.Object)">push()</a> - Push a new
    object onto the top of the stack.</li>
</ul>

<p>A typical design pattern, then, is to trigger an action that creates a new
object and pushes it on the stack when the beginning of a particular XML 
element is encountered. The object will remain there while the nested content
of this element is processed, and it will be popped off when the end of the
element is encountered.  As we will see, the standard CreateObjectAction
supports exactly this functionalility in a very convenient way.</p>

<p>Several potential issues with this design pattern are addressed by other
features of the Digester functionality:</p>

<ul>
<li><em>How do I relate the objects being created to each other?</em> - The
    Digester supports standard processing actions that pass the top object on
    the stack as an argument to a named method on the next-to-top object on
    the stack (or vice versa).  This action makes it easy to establish
    parent-child relationships between these objects.  One-to-one and
    one-to-many relationships are both easy to construct.</li>
<li><em>How do I retain a reference to the first object that was created?</em>
    As you review the description of what the CreateObjectAction class
    does, it would appear that the first object you create (i.e. the object
    created by the outermost XML element you process) will disappear from the
    stack by the time that XML parsing is completed, because the end of the
    element would have been encountered.  However, Digester will maintain a
    reference to the very first object ever pushed onto the object stack,
    and will return it to you as the return value from the <code>parse()</code>
    call.  Alternatively, you can push a reference to some application object
    onto the stack before calling <code>parse()</code>, and arrange that a
    parent-child relationship be created (by appropriate processing actions)
    between this manually pushed object and the ones that are dynamically
    created.  In this way, the pushed object will retain a reference to the
    dynamically created objects (and therefore all of their children), and will
    be returned to you after the parse finishes as well.</li>
</ul>

<a name="doc.Patterns"></a>
<h3>Element Matching Patterns</h3>

<p>A primary feature of the <code>org.apache.commons.digester.Digester</code>
parser is that the Digester automatically navigates the element hierarchy of
the XML document you are parsing for you, without requiring any developer
attention to this process.  Instead, you focus on deciding what actions you
would like to have performed whenver a certain arrangement of nested elements
is encountered in the XML document being parsed.  The mechanism for specifying
such arrangements are called <em>element matching patterns</em>.</p>

<p>A (pattern, action) pair is referred to as a "rule".</p>

<p>A very simple element matching pattern is a simple string like "/a".  This
pattern is matched if-and-only-if the document's root element is 
<code>&lt;a&gt;</code>.</p>

<p>The next step up in matching pattern complexity is "/a/b".  This pattern will
be matched when a <code>&lt;b&gt;</code> element is found nested inside a
top-level <code>&lt;a&gt;</code> element.  This match can occur as many
times as desired, depending on the content of the XML document being parsed.
You can use multiple slashes to define a hierarchy of any desired depth that
will be matched appropriately.</p>

<p>For example, assume you have registered processing rules for patterns
"/a", "/a/b", and "/a/b/c".  For an input XML document with the following
contents, the indicated patterns will be matched when the corresponding element
is parsed:</p>
<pre>
  &lt;a&gt;         -- Matches pattern "/a"
    &lt;b&gt;       -- Matches pattern "/a/b"
      &lt;c/&gt;    -- Matches pattern "/a/b/c"
      &lt;c/&gt;    -- Matches pattern "/a/b/c"
    &lt;/b&gt;
    &lt;b&gt;       -- Matches pattern "/a/b"
      &lt;c/&gt;    -- Matches pattern "/a/b/c"
      &lt;c/&gt;    -- Matches pattern "/a/b/c"
      &lt;c/&gt;    -- Matches pattern "/a/b/c"
    &lt;/b&gt;
  &lt;/a&gt;
</pre>

<p>It is also possible to match a particular XML element, no matter how it is
nested (or not nested) in the XML document, by leaving off the leading slash
character in your matching pattern strings.  For example, an element matching
pattern of "a" will match an <code>&lt;a&gt;</code> element at any nesting
position within the document, and a pattern of "a/b" will match a
<code>&lt;b&gt;</code> element which is a direct child of an 
<code>&lt;a&gt;</code> element anywhere in the document.</p>

<p>It is quite possible that, when a particular XML element is being parsed,
the pattern for more than one registered processing rule will be matched
either because you registered more than one processing rule with the same
matching pattern, or because one more more exact pattern matches and wildcard
pattern matches are satisfied by the same element.</p>

<p>When this occurs, the corresponding processing actions for the matching rules
will all be fired in order. The <code>begin</code> (and <code>body</code>) 
method calls are executed in the order that the <code>Action</code> objects
were initially registered with the <code>Digester</code>, whilst <code>end</code>
method calls are execute in reverse order. In other words - the order is first
in, last out.</p>

<a name="doc.Actions"></a>
<h3>Processing Actions</h3>

<p>The <a href="#doc.Patterns">previous section</a> documented how you identify
<strong>when</strong> you wish to have certain actions take place.  The purpose
of processing actions is to define <strong>what</strong> should happen when the
patterns are matched.</p>

<p>Formally, a processing action is a Java class that subclasses the
<a href="Action.html">Action</a> interface. Each Action implements one or more
of the following event methods that are called at well-defined times when the
matching patterns corresponding to this action trigger it:</p>
<ul>
<li><a href="Action.html#begin">begin</a> -
    Called when the beginning of the matched XML element is encountered.  A
    data structure containing all of the attributes corresponding to this
    element are passed as well.</li>
<li><a href="Action.html#body">body</a> -
    Called when nested content (that is not itself XML elements) of the
    matched element is encountered.</li>
<li><a href="Action.html#end">end</a> - Called when the ending of the matched
    XML element is encountered.  If nested XML elements that matched other
    processing actions was included in the body of this element, the appropriate
    processing rules for the matched actions will have already been completed
    before this method is called.</li>
<li><a href="Action.html#startParse">startParse</a> - Called when parsing of
    an input document is about to start, to give each action a chance to 
    perform any per-parse initialisation it wishes to do.</li>
<li><a href="Action.html#finishParse">finishParse</a> - Called when the parse
    has been completed, to give each action a chance to clean up any temporary
    data it might have created and cached.</li>
</ul>

<p>As you are configuring your digester, you can call the
<code>addRule()</code> method to register a specific element matching pattern,
along with an instance of an <code>Action</code> class that will have its event
handling methods called at the appropriate times, as described above.  This
mechanism allows you to create <code>Action</code> implementation classes
dynamically, to implement any desired application specific functionality.</p>

<p>In addition, a set of processing action implementation classes are provided,
which deal with many common programming scenarios.  These classes include the
following:</p>
<ul>
<li><a href="actions/CreateObjectAction.html">CreateObjectAction</a> - When the
    <code>begin</code> method is called, this action creates a new
    instance of a specified Java class, and pushes it on the stack.  The
    class name to be used is specified in a parameter passed to
    this action's constructor, but the input xml can optionally override this
    by using an xml attribute to specify an alternative classname.
    When the <code>end</code> method is called, the top object on the stack
    (presumably, the one we added in the <code>begin</code> method) will
    be popped, and any reference to it (within the Digester) will be
    discarded.</li>
<li><a href="actions/CreateObjectWithFactoryAction.html">
    CreateObjectWithFactoryAction</a> - A variation of
    <code>CreateObjectAction</code> that is useful when the Java class with
    which you wish to create an object instance does not have a no-arguments
    constructor, or where you wish to perform other setup processing before
    the object is handed over to the Digester.</li>
<li><a href="actions/SetPropertiesAction.html">SetPropertiesAction</a> - When
    the <code>begin</code> method is called, the digester uses the standard
    Java Reflection API to identify any JavaBeans property setter methods
    (on the object at the top of the digester's stack) which have property
    names that match the attributes specified on this XML element, and then
    call them individually, passing the corresponding attribute values. These
    natural mappings can be overridden. This allows (for example) a 
    <code>class</code> attribute to be mapped correctly. It is recommended
    that this override feature should not be overused - in most cases, it's
    better to use the standard <code>BeanInfo</code> mechanism.
    A very common idiom is to define a "create-object" action followed by a
    "set-properties" action, with the same element matching pattern.  This
    causes the creation of a new Java object, followed by "configuration" of
    that object's properties based on the attributes of the same XML element
    that created this object.</li>
<li><a href="actions/SetPropertyAction.html">SetPropertyAction</a> - When the
    <code>begin</code> method is called, the digester calls a specified
    property setter (where the property itself is named by an attribute)
    with a specified value (where the value is named by another attribute),
    on the object at the top of the digester's stack.
    This is useful when your XML file conforms to a particular DTD, and
    you wish to configure a particular property that does not have a
    corresponding attribute in the DTD.</li>
<li><a href="actions/LinkObjectsAction.html">LinkObjectsAction</a> - Allows
    one object on the digester stack to be passed to some other object on the
    digester stack. Presumably the recipient stores a reference to the parameter
    object somewhere for later use. The most common use of this action is to
    establish parent/child relationships between the (top-1) object on the
    stack and the (top) object on the stack, with the method name commonly
    being called something like "addChild".</li>
<li><a href="actions/CallMethodAction.html">CallMethodAction</a> - This action
    sets up a  method call to a specified method on some object on the 
    digester's stack. The target object is usually the top object on the stack. 
    The call to the method will actually take place when the <code>end</code>
    method of the action is called.  You configure this action by specifying the
    name of the method to be called, the number of arguments it takes, and 
    (optionally) the Java class name(s) defining the type(s) of the method's 
    arguments. The actual parameter values, if any, will typically be 
    accumulated from the body content of nested elements within the element
    that triggered this action, using the CallParam..Action actions discussed
    in the following section.</li>
<li>CallParam Actions</a> - There is a set of actions with names of form
    <code>CallParam....Action</code>, eg CallParamBodyAction. These actions are
    all intended to be used together with a CallMethodAction to select values
    for the method call defined by the CallMethod action. Flavours exist to
    select data from an xml element's attributes, its body text, from the
    digester object stack, and several other options.</li>
<li><a href="actions/CreateNodeAction.html">CreateNodeAction</a> - A 
    specialized action that converts part of the xml input into a 
    <code>DOM Node</code> and then pushes it onto the stack.</li>
</ul>

<a name="doc.ActionFactory"></a>
<h3>The Action Factory</h3>

<p>You can create instances of the standard <code>Action</code> classes and
register them by calling <code>digester.addRule()</code>, as described above.
However, because their usage is so common, the ActionFactory class provides
a set of shorthand registration methods. For example, the following code 
sequence:</p>
<pre>
    Action action = new LinkObjectsAction("addChild",
                                "com.mycompany.mypackage.MyChildClass");
    digester.addRule("/a/b/c", action);
</pre>
<p>can be replaced by:</p>
<pre>
    ActionFactory factory = new ActionFactory(digester);
    factory.addLinkObjects("/a/b/c", "addChild",
                        "com.mycompany.mypackage.MyChildClass");
</pre>

<a name="doc.Logging"></a>
<h3>Logging</h3>

<p>Logging is a vital tool for debugging Digester operation. Digester can log
copious amounts of debugging information. So, you need to know how logging
works before you start using Digester seriously.</p>

<p>Digester uses
<a href="http://jakarta.apache.org/commons/logging.html">Jakarta Commons
Logging</a>.  This component is not really a logging framework - rather
an extensible, configurable bridge. It can be configured to swallow all log 
messages, to provide very basic logging by itself or to pass logging messages
on to more sophisticated logging frameworks. Commons-Logging comes with
connectors for many popular logging frameworks. Consult the commons-logging
documentation for more information.</p>

<p>Two main logs are used by Digester:</p>
<ul>
<li>SAX-related messages are logged to
    <strong><code>org.apache.commons.digester.Digester.sax</code></strong>.
    This log gives information about the basic SAX events received by
    Digester.</li>
<li><strong><code>org.apache.commons.digester.Digester</code></strong> is used
    for everything else. You'll probably want to have this log turned up during
    debugging but turned down during production due to the high message
    volume.</li>
</ul>

<p>Complete documentation of how to configure Commons-Logging can be found
in the Commons Logging package documentation.  However, as a simple example,
let's assume that you want to use the <code>SimpleLog</code> implementation
that is included in Commons-Logging, and set up Digester to log events from
the <code>Digester</code> logger at the DEBUG level, while you want to log
events from the <code>Digester.log</code> logger at the INFO level.  You can
accomplish this by creating a <code>commons-logging.properties</code> file
in your classpath (or setting corresponding system properties on the command
line that starts your application) with the following contents:</p>
<pre>
  org.apache.commons.logging.Log=org.apache.commons.logging.impl.SimpleLog
  org.apache.commons.logging.simplelog.log.org.apache.commons.digester.Digester=debug
  org.apache.commons.logging.simplelog.log.org.apache.commons.digester.Digester.sax=info
</pre>

<a name="doc.Usage"></a>
<h3>Usage Examples</h3>


<h5>Creating a Simple Object Tree</h5>

<p>Let's assume that you have two simple JavaBeans, <code>Foo</code> and
<code>Bar</code>, with the following method signatures:</p>
<pre>
  package mypackage;
  public class Foo {
    public void addBar(Bar bar);
    public Bar findBar(int id);
    public Iterator getBars();
    public String getName();
    public void setName(String name);
  }

  public mypackage;
  public class Bar {
    public int getId();
    public void setId(int id);
    public String getTitle();
    public void setTitle(String title);
  }
</pre>

<p>and you wish to use Digester to parse the following XML document:</p>

<pre>
  &lt;foo name="The Parent"&gt;
    &lt;bar id="123" title="The First Child"/&gt;
    &lt;bar id="456" title="The Second Child"/&gt;
  &lt;/foo&gt;
</pre>

<p>A simple approach will be to use the following Digester in the following way
to set up the parsing rules, and then process an input file containing this
document:</p>

<pre>
  Digester digester = new Digester();
  ActionFactory factory = new ActionFactory(digester);
  factory.addCreateObject("/foo", "mypackage.Foo");
  factory.addSetProperties("/foo");
  factory.addCreateObject("/foo/bar", "mypackage.Bar");
  factory.addSetProperties("/foo/bar");
  factory.addLinkObjects("/foo/bar", "addBar", "mypackage.Bar");
  Foo foo = (Foo) digester.parse();
</pre>

<p>In order, these rules do the following tasks:</p>
<ol>
<li>When the outermost <code>&lt;foo&gt;</code> element is encountered,
    create a new instance of <code>mypackage.Foo</code> and push it
    on to the object stack.  At the end of the <code>&lt;foo&gt;</code>
    element, this object will be popped off of the stack.</li>
<li>Cause properties of the top object on the stack (i.e. the <code>Foo</code>
    object that was just created and pushed) to be set based on the values
    of the attributes of this XML element.</li>
<li>When a nested <code>&lt;bar&gt;</code> element is encountered,
    create a new instance of <code>mypackage.Bar</code> and push it
    on to the object stack.  At the end of the <code>&lt;bar&gt;</code>
    element, this object will be popped off of the stack (i.e. after the
    remaining rules matching <code>/foo/bar</code> are processed).</li>
<li>Cause properties of the top object on the stack (i.e. the <code>Bar</code>
    object that was just created and pushed) to be set based on the values
    of the attributes of this XML element.  Note that type conversions
    are automatically performed (such as String to int for the <code>id</code>
    property), for all converters registered with the <code>ConvertUtils</code>
    class from <code>commons-beanutils</code> package.</li>
<li>Cause the <code>addBar</code> method of the next-to-top element on the
    object stack to be called, passing the element that is on the top of the
    stack, which must be of type <code>mypackage.Bar</code>.  This is the rule
    that causes the parent/child relationship to be created.</li>
</ol>

<p>Once the parse is completed, the first object that was ever pushed on to the
stack (the <code>Foo</code> object in this case) is returned to you.  It will
have had its properties set, and all of its child <code>Bar</code> objects
created for you.</p>


<h5>Processing A Struts Configuration File</h5>

<p>As stated earlier, the primary reason that the
<code>Digester</code> package was created is because the
Struts controller servlet itself needed a robust, flexible, easy to extend
mechanism for processing the contents of the <code>struts-config.xml</code>
configuration that describes nearly every aspect of a Struts-based application.
Because of this, the controller servlet contains a comprehensive, real world,
example of how the Digester can be employed for this type of a use case.
See the <code>initDigester()</code> method of class
<code>org.apache.struts.action.ActionServlet</code> for the code that creates
and configures the Digester to be used, and the <code>initMapping()</code>
method for where the parsing actually takes place.</p>

<p>(Struts binary and source distributions can be acquired at
<a href="http://jakarta.apache.org/struts/">http://jakarta.apache.org/struts/</a>.)</p>

<p>The following discussion highlights a few of the matching patterns and
processing actions that are configured, to illustrate the use of some of the
Digester features.  First, let's look at how the Digester instance is
created and initialized:</p>
<pre>
    Digester digester = new Digester();
    digester.setInitialObject(this);
    digester.setValidating(true);
</pre>

<p>We see that a new Digester instance is created, and is configured to use
a validating parser.  Validation will occur against the struts-config_1_0.dtd
DTD that is included with Struts (as discussed earlier).  In order to provide
a means of tracking the configured objects, the controller servlet instance
itself will be added to the digester's stack.</p>

<pre>
    ActionFactory factory = new ActionFactory(digester);
    factory.addCreateObject("/struts-config/global-forwards/forward",
                             forwardClass, "className");
    factory.addSetProperties("/struts-config/global-forwards/forward");
    factory.addLinkObjects("/struts-config/global-forwards/forward",
                        "addForward",
                        "org.apache.struts.action.ActionForward");
    factory.addSetProperty(
        "/struts-config/global-forwards/forward/set-property",
       "property", "value");
</pre>

<p>The rules created by these lines are used to process the global forward
declarations.  When a <code>&lt;forward&gt;</code> element is encountered,
the following actions take place:</p>
<ul>
<li>A new object instance is created -- the <code>ActionForward</code>
    instance that will represent this definition.  The Java class name
    defaults to that specified as an initialization parameter (which
    we have stored in the String variable <code>forwardClass</code>), but can
    be overridden by using the "className" attribute (if it is present in the
    XML element we are currently parsing).  The new <code>ActionForward</code>
    instance is pushed onto the stack.</li>
<li>The properties of the <code>ActionForward</code> instance (at the top of
    the stack) are configured based on the attributes of the
    <code>&lt;forward&gt;</code> element.</li>
<li>Nested occurrences of the <code>&lt;set-property&gt;</code> element
    cause calls to additional property setter methods to occur.  This is
    required only if you have provided a custom implementation of the
    <code>ActionForward</code> class with additional properties that are
    not included in the DTD.</li>
<li>The <code>addForward()</code> method of the next-to-top object on
    the stack (i.e. the controller servlet itself) will be called, passing
    the object at the top of the stack (i.e. the <code>ActionForward</code>
    instance) as an argument.  This causes the global forward to be
    registered, and as a result of this it will be remembered even after
    the stack is popped.</li>
<li>At the end of the <code>&lt;forward&gt;</code> element, the top element
    (i.e. the <code>ActionForward</code> instance) will be popped off the
    stack.</li>
</ul>

<p>Later on, the digester is actually executed as follows:</p>
<pre>
    InputStream input =
      getServletContext().getResourceAsStream(config);
    ...
    try {
        digester.parse(input);
        input.close();
    } catch (SAXException e) {
        ... deal with the problem ...
    }
</pre>

<p>As a result of the call to <code>parse()</code>, all of the configuration
information that was defined in the <code>struts-config.xml</code> file is
now represented as collections of objects cached within the Struts controller
servlet, as well as being exposed as servlet context attributes.</p>


<h5>Parsing Body Text In XML Files</h5>

<p>The Digester module also allows you to process the nested body text in an
XML file, not just the elements and attributes that are encountered.  The
following example is based on an assumed need to parse the web application
deployment descriptor (<code>/WEB-INF/web.xml</code>) for the current web
application, and record the configuration information for a particular
servlet.  To record this information, assume the existence of a bean class
with the following method signatures (among others):</p>
<pre>
  package com.mycompany;
  public class ServletBean {
    public void setServletName(String servletName);
    public void setServletClass(String servletClass);
    public void addInitParam(String name, String value);
  }
</pre>

<p>We are going to process the <code>web.xml</code> file that declares the
controller servlet in a typical Struts-based application (abridged for
brevity in this example):</p>
<pre>
  &lt;web-app&gt;
    ...
    &lt;servlet&gt;
      &lt;servlet-name&gt;action&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.apache.struts.action.ActionServlet&lt;servlet-class&gt;
      &lt;init-param&gt;
        &lt;param-name&gt;application&lt;/param-name&gt;
        &lt;param-value&gt;org.apache.struts.example.ApplicationResources&lt;param-value&gt;
      &lt;/init-param&gt;
      &lt;init-param&gt;
        &lt;param-name&gt;config&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/struts-config.xml&lt;param-value&gt;
      &lt;/init-param&gt;
    &lt;/servlet&gt;
    ...
  &lt;/web-app&gt;
</pre>

<p>Next, lets define some Digester processing rules for this input file:</p>
<pre>
  factory.addCreateObject("/web-app/servlet", "com.mycompany.ServletBean");
  factory.addSetProperty("/web-app/servlet/servlet-name");
  factory.addSetProperty("/web-app/servlet/servlet-class");
  factory.addCallMethod("/web-app/servlet/init-param",
                         "addInitParam", 2);
  factory.addCallParamBody("/web-app/servlet/init-param/param-name", 0);
  factory.addCallParamBody("/web-app/servlet/init-param/param-value", 1);
</pre>

<p>Now, as elements are parsed, the following processing occurs:</p>
<ul>
<li><em>&lt;servlet&gt;</em> - A new <code>com.mycompany.ServletBean</code>
    object is created, and pushed on to the object stack.</li>
<li><em>&lt;servlet-name&gt;</em> - The <code>setServletName()</code> method
    of the top object on the stack (our <code>ServletBean</code>) is called,
    passing the body content of this element as a single parameter.</li>
<li><em>&lt;servlet-class&gt;</em> - The <code>setServletClass()</code> method
    of the top object on the stack (our <code>ServletBean</code>) is called,
    passing the body content of this element as a single parameter.</li>
<li><em>&lt;init-param&gt;</em> - A call to the <code>addInitParam</code>
    method of the top object on the stack (our <code>ServletBean</code>) is
    set up, but it is <strong>not</strong> called yet.  The call will be
    expecting two <code>String</code> parameters, which must be set up by
    subsequent call parameter rules.</li>
<li><em>&lt;param-name&gt;</em> - The body content of this element is assigned
    as the first (zero-relative) argument to the call we are setting up.</li>
<li><em>&lt;param-value&gt;</em> - The body content of this element is assigned
    as the second (zero-relative) argument to the call we are setting up.</li>
<li><em>&lt;/init-param&gt;</em> - The call to <code>addInitParam()</code>
    that we have set up is now executed, which will cause a new name-value
    combination to be recorded in our bean.</li>
<li><em>&lt;init-param&gt;</em> - The same set of processing rules are fired
    again, causing a second call to <code>addInitParam()</code> with the
    second parameter's name and value.</li>
<li><em>&lt;/servlet&gt;</em> - The element on the top of the object stack
    (which should be the <code>ServletBean</code> we pushed earlier) is
    popped off the object stack.</li>
</ul>


<a name="doc.Namespace"></a>
<h3>Handling documents that use xml namespaces</h3>

<p>Digester 2.0 has full support for xml namespaces. Before adding rules,
simply define a set of (prefix->namespace) mappings via the 
<code>Digester.addNamespace</code> method. The patterns that are then passed
to the addRule method may then use any of the prefixes that have been defined.
</p>

<p>Element names in a pattern which do not have a prefix will match only
xml elements which are in no namespace.</p>

<p>As an example, consider what happens when the following document:
<pre>
&lt;m:foo
   xmlns:m="http://www.mycompany.com/MyNamespace"
   xmlns:y="http://www.yourcompany.com/YourNamespace"&gt;

  &lt;m:bar name="My Name" value="My Value"/&gt;
  &lt;y:bar id="123" product="Product Description"/&gt;
  &lt;bar id="123" product="Product Description"/&gt;

&lt;/x:foo&gt;
</pre>
is parsed with these rules:
<pre>
  digester.addNamespace("mns", "http://www.mycompany.com/MyNamespace");
  digester.addRule("/mns:foo/mns:bar", new CreateObjectAction());
  digester.addRule("/mns:foo/mns:bar", new SetPropertiesAction());
</pre>
</p>

<p>The create-object and set-properties actions will be fired for the
<em>first</em> occurrence of the <code>bar</code> element, but not the
<em>second</em> or <em>third</em> ones.  This is because we declared that
our rules only matched for the particular namespace we are interested in.  
Any elements in the document that are associated with other namespaces 
(or no namespaces at all) will not match these patterns.</p>

<p>Note also that there is no need for the namespace prefixes used in the
patterns to be identical to the namespace prefixes used in the input document.
What is important is that the namespace URI referred to by the prefixes is the
same. This is a normal (and important) feature of xml namespaces. However in
most cases a namespace URI has a "traditional" prefix string, and it
would be logical and convenient for your patterns to use the traditional
prefixes in order to make the patterns more readable.</p>

<a name="doc.Pluggable"></a>
<h3>Pluggable Rules Processing</h3>

<p>By default, <code>Digester</code> selects the actions that match a particular
pattern of nested elements as described under
<a href="#doc.Patterns">Element Matching Patterns</a>.  If you prefer to use
different selection policies, however, you can create your own implementation
of the <a href="RuleManager.html">RuleManager</a> interface, or subclass the
AbstractRuleManager base class.</p>

<a name="doc.RegisteringDTDs"></a>
<h3>Registering DTDs</h3>

<h4>Brief (But Still Too Long) Introduction To System and Public Identifiers</h4>
<p>A definition for an external entity comes in one of two forms:
</p>
<ol>
    <li><code>SYSTEM <em>system-identifier</em></code></li>
    <li><code>PUBLIC <em>public-identifier</em> <em>system-identifier</em></code></li>
</ol>
<p>
The <code><em>system-identifier</em></code> is an URI from which the resource can be obtained
(either directly or indirectly). Many valid URIs may identify the same resource.
The <code><em>public-identifier</em></code> is an additional free identifier which may be used
(by the parser) to locate the resource. 
</p>
<p>
In practice, the weakness with a <code><em>system-identifier</em></code> is that most parsers
will attempt to interprete this URI as an URL, try to download the resource directly
from the URL and stop the parsing if this download fails. So, this means that 
almost always the URI will have to be an URL from which the declaration
can be downloaded.
</p>
<p>
URLs may be local or remote but if the URL is chosen to be local, it is likely only
to function correctly on a small number of machines (which are configured precisely
to allow the xml to be parsed). This is usually unsatisfactory and so a universally
accessable URL is preferred. This usually means an internet URL.
</p>
<p>
To recap, in practice the <code><em>system-identifier</em></code> will (most likely) be an 
internet URL. Unfortunately downloading from an internet URL is not only slow
but unreliable (since successfully downloading a document from the internet 
relies on the client being connect to the internet and the server being
able to satisfy the request).
</p>
<p>
The <code><em>public-identifier</em></code> is a freely defined name but (in practice) it is 
strongly recommended that a unique, readable and open format is used (for reasons
that should become clear later). A Formal Public Identifier (FPI) is a very
common choice. This public identifier is often used to provide a unique and location
independent key which can be used to subsistute local resources for remote ones 
(hint: this is why ;).
</p>
<p>
By using the second (<code>PUBLIC</code>) form combined with some form of local
catalog (which matches <code><em>public-identifiers</em></code> to local resources) and where
the <code><em>public-identifier</em></code> is a unique name and the <code><em>system-identifier</em></code> 
is an internet URL, the practical disadvantages of specifying just a 
<code><em>system-identifier</em></code> can be avoided. Those external entities which have been 
store locally (on the machine parsing the document) can be identified and used.
Only when no local copy exists is it necessary to download the document
from the internet URL. This naming scheme is recommended when using <code>Digester</code>.
</p>

<h4>External Entity Resolution Using Digester</h4>
<p>
SAX factors out the resolution of external entities into an 
<code>EntityResolver</code>. <code>Digester</code> supports the use of custom 
<code>EntityResolver</code> objects but ships with a simple internal 
implementation. This implementation allows local URLs to be easily 
associated with <code><em>public-identifiers</em></code>. 
</p>
<p>For example:</p>
<code><pre>
    digester.registerKnownEntity(
        "-//Example Dot Com //DTD Sample Example//EN", 
        "assets/sample.dtd");
</pre></code>
<p>
will make digester return the relative file path <code>assets/sample.dtd</code> 
whenever an external entity with public id 
<code>-//Example Dot Com //DTD Sample Example//EN</code> is needed.
</p>
<p><strong>Note:</strong> This is a simple (but useful) implementation. 
Greater sophistication requires a custom <code>EntityResolver</code>.</p>
    
<a name="doc.troubleshooting"></a>
<h3>Troubleshooting</h3>
<h4>Debugging Exceptions</h4>
<p>
<code>Digester</code> is based on <a href='http://www.saxproject.org'>SAX</a>.
Digestion throws two kinds of <code>Exception</code>:
</p>
<ul>
    <li><code>java.io.IOException</code></li>
    <li><code>org.xml.sax.SAXException</code></li>
</ul>
<p>
The first is rarely thrown and indicates the kind of fundemental IO exception
that developers know all about. The second is thrown by SAX parsers when the processing
of the XML cannot be completed. So, to diagnose the cause a certain familiarity with 
the way that SAX error handling works is very useful. 
</p>

<h5>Diagnosing SAX Exceptions</h5>
<p>This is a short, potted guide to SAX error handling strategies. It's not intended as a
proper guide to error handling in SAX.</p>

<p>When a SAX parser encounters a problem with the xml (well, ok - sometime after it 
encounters a problem) it will throw a 
<a href='http://www.saxproject.org/apidoc/org/xml/sax/SAXParseException.html'>
SAXParseException</a>. This is a subclass of <code>SAXException</code> and contains
a bit of extra information about what exactly when wrong - and more importantly,
where it went wrong. If you catch an exception of this sort, you can be sure that
the problem is with the XML and not <code>Digester</code> or your actions.
It is usually a good idea to catch this exception and log the extra information
to help with diagnosing the reason for the failure.</p>

<p>General <a href='http://www.saxproject.org/apidoc/org/xml/sax/SAXException.html'>
SAXException</a> instances may wrap a causal exception. When exceptions are
throw by <code>Digester</code> each of these will be wrapped into a 
<code>SAXException</code> and rethrown. So, catch these and examine the wrapped
exception to diagnose what went wrong.</p>

<a name="doc.FAQ"></a>
<h3>Frequently Asked Questions</h3>

<ul>

<li><strong>Why do I get warnings when using a JAXP 1.1 parser?</strong>
  <p>If you're using a JAXP 1.1 parser, you might see the following warning 
  (in your log):<code><pre>[WARN] Digester - -Error: JAXP SAXParser property 
  not recognized: http://java.sun.com/xml/jaxp/properties/schemaLanguage
  </pre></code>
  This property is needed for JAXP 1.2 (XML Schema support) as required
  for the Servlet Spec. 2.4 but is not recognized by JAXP 1.1 parsers.
  This warning is harmless.</p>
</li>

<li><strong>Why Doesn't Schema Validation Work With Parser XXX Out Of The Box?</strong>
  <p>Schema location and language settings are often need for validation
  using schemas. Unfortunately, there isn't a single standard approach to how
  these properties are configured on a parser.   Digester tries to guess the
  parser being used and configure it appropriately but it's not infallible.
  You might need to grab an instance, configure it and pass it to Digester.</p>

  <p>If you want to support more than one parser in a portable manner, then
  you'll probably want to take a look at the
  <code>org.apache.commons.digester.parsers</code> package and add a new class
  to support the particular parser that's causing problems.</p>
</li>

<li><strong>Where Can I Find Example Code?</strong>
  <a name="doc.FAQ.Examples">
  <p>Digester source distributions include a set of examples demonstrating most
  of the features described in this document. See the "src/examples" subdirectory 
  of the source distribution.</p>
</li>

</ul>

<a name="doc.extensions"></a>
<h3>Extensions</h3>

<p>
Three extension packages are included within the Digester distribution.
These provide extra functionality extending the core Digester concepts.
Detailed descriptions are contained within their own package documentation.
</p>

<ul>
<li>
  <a href='plugins/package-summary.html'>plugins</a> provides a framework for
  the easy dynamic addition of rules during a Digestion. Rules can trigger the
  dynamic addition of other rules in an intuitive fashion.
</li>

<li>
  <a href='substitution/package-summary.html'>substitution</a> provides for 
  manipulation of attributes and element body text before it is processed by
  the rules.
</li>

<li>
  <a href='xmlrules/package-summary.html'>xmlrules</a> package contains a
  system allowing digester rule configurations to be specifed through an xml
  file.
</li>
</ul>

<a name="doc.Limits"></a>
<h3>Known Limitations</h3>
<h4>Accessing Public Methods In A Default Access Superclass</h4>
<p>There is an issue when invoking public methods contained in a default access superclass.
Reflection locates these methods fine and correctly assigns them as public.
However, an <code>IllegalAccessException</code> is thrown if the method is invoked.</p>

<p><code>MethodUtils</code> contains a workaround for this situation. 
It will attempt to call <code>setAccessible</code> on this method.
If this call succeeds, then the method can be invoked as normal.
This call will only succeed when the application has sufficient security privilages. 
If this call fails then a warning will be logged and the method may fail.</p>

<p><code>Digester</code> uses <code>MethodUtils</code> and so there may be an issue accessing methods
of this kind from a high security environment. If you think that you might be experiencing this 
problem, please ask on the mailing list.</p>
</body>
</html>
